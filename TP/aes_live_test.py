# Python 2.7 compatible AES-128 ECB (pur Python)
# Entrees/sorties en hex (32 chars), renvoie 32 hex chars (lowercase)

# -------- utils bytes <-> ints --------
def _hex_to_bytes(h):
    if len(h) % 2: h = '0' + h
    return [int(h[i:i+2], 16) for i in range(0, len(h), 2)]

def _bytes_to_hex(b):
    return ''.join('{:02x}'.format(x & 0xff) for x in b)

# -------- AES core tables --------
SBOX = [
  # 0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
  0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
  0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
  0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
  0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
  0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
  0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
  0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
  0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
  0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
  0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
  0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
  0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
  0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
  0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
  0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
  0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
]
RCON = [0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36]

def _xtime(a): 
    a <<= 1
    if a & 0x100: a ^= 0x11B
    return a & 0xFF

def _mul(a,b):
    res = 0
    for i in range(8):
        if b & 1: res ^= a
        hi = a & 0x80
        a = (a << 1) & 0xFF
        if hi: a ^= 0x1B
        b >>= 1
    return res

def _sub_bytes(s):
    for i in range(16): s[i] = SBOX[s[i]]

def _shift_rows(s):
    s[1], s[5], s[9],  s[13] = s[5],  s[9],  s[13], s[1]
    s[2], s[6], s[10], s[14] = s[10], s[14], s[2],  s[6]
    s[3], s[7], s[11], s[15] = s[15], s[3],  s[7],  s[11]

def _mix_columns(s):
    for c in range(4):
        i = 4*c
        a0,a1,a2,a3 = s[i:i+4]
        s[i+0] = _mul(a0,2) ^ _mul(a1,3) ^ a2 ^ a3
        s[i+1] = a0 ^ _mul(a1,2) ^ _mul(a2,3) ^ a3
        s[i+2] = a0 ^ a1 ^ _mul(a2,2) ^ _mul(a3,3)
        s[i+3] = _mul(a0,3) ^ a1 ^ a2 ^ _mul(a3,2)

def _add_round_key(s, rk):
    for i in range(16):
        s[i] ^= rk[i]

def _key_expand_128(key_bytes):
    # key_bytes: 16 bytes
    w = [0]*176  # 11 round keys * 16 bytes
    for i in range(16):
        w[i] = key_bytes[i]
    bytes_generated = 16
    rcon_iter = 1
    temp = [0]*4
    while bytes_generated < 176:
        for i in range(4):
            temp[i] = w[bytes_generated - 4 + i]
        if bytes_generated % 16 == 0:
            # RotWord
            temp = temp[1:]+temp[:1]
            # SubWord
            for i in range(4):
                temp[i] = SBOX[temp[i]]
            temp[0] ^= RCON[rcon_iter]
            rcon_iter += 1
        for i in range(4):
            w[bytes_generated] = (w[bytes_generated - 16] ^ temp[i]) & 0xFF
            bytes_generated += 1
    rks = []
    for r in range(11):
        rks.append(w[16*r:16*(r+1)])
    return rks

def _aes128_encrypt_block(pt16, key16):
    state = pt16[:]  # 16 bytes list
    round_keys = _key_expand_128(key16)
    _add_round_key(state, round_keys[0])
    for rnd in range(1,10):
        _sub_bytes(state)
        _shift_rows(state)
        _mix_columns(state)
        _add_round_key(state, round_keys[rnd])
    _sub_bytes(state)
    _shift_rows(state)
    _add_round_key(state, round_keys[10])
    return state

def AES_ref_py(pt_hex, key_hex):
    # pt_hex/key_hex: 32 hex chars
    pt  = _hex_to_bytes(pt_hex.lower())
    key = _hex_to_bytes(key_hex.lower())
    if len(pt) != 16 or len(key) != 16:
        raise ValueError("AES_ref_py expects 16-byte pt/key (32 hex chars)")
    ct = _aes128_encrypt_block(pt, key)
    return _bytes_to_hex(ct)

